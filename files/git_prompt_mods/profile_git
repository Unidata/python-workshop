#
# Add Git Branch to Prompt
#
#a black
#b red
#c green
#d brown
#e blue
#f magenta
#g cyan
#h light grey
#A bold black, usually shows up as dark grey
#B bold red
#C bold green
#D bold brown, usually shows up as yellow
#E bold blue
#F bold magenta
#G bold cyan
#H bold light grey; looks like bright white
#x default foreground or background

#1. directory
#2. symbolic link
#3. socket
#4. pipe
#5. executable
#6. block special
#7. character special
#8. executable with setuid bit set
#9. executable with setgid bit set
#10. directory writable to others, with sticky bit
#11. directory writable to others, without sticky bit
# LSCOLORS set in pairs of foreground/background
export CLICOLOR=True
export LSCOLORS=exfxcxdxbxegedabagacad

if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
    c_reset='\[\e[0m\]'
    c_user='\[\e[1;32m\]'
    c_path='\[\e[0;35m\]'
    c_git_clean='\[\e[0;32m\]'
    c_git_dirty='\[\e[0;31m\]'
else
    c_reset=
    c_user=
    c_path=
    c_git_clean=
    c_git_dirty=
fi
 
# Function to assemble the Git part of our prompt.
git_prompt ()
{
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        return 0
    fi
 
    git_branch=$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')
 
    if git diff --quiet 2>/dev/null >&2; then
        git_color="$c_git_clean"
    else
        git_color="$c_git_dirty"
    fi
 
    echo " [$git_color$git_branch${c_reset}]"
} 

git_prompt ()
{
    eval 'echo -ne "\033]0;${USER}@${HOSTNAME%%.*}: ${PWD}\007"'
    PS1="${c_user}\u${c_reset}@${c_user}\h${c_reset}:$(git_prompt)\$ "
}
PROMPT_COMMAND=git_prompt
